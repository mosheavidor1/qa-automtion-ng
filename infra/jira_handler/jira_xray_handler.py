import json
from enum import Enum

import allure
import requests

import third_party_details
from infra.allure_report_handler.reporter import Reporter
from infra.system_components.aggregator import Aggregator
from infra.system_components.collector import CollectorAgent
from infra.system_components.core import Core
from infra.system_components.management import Management


class JiraConfiguration:

    endpoint = 'http://jira.ensilo.local'
    user_name = third_party_details.USER_NAME
    password = third_party_details.PASSWORD
    project = 'EN'


class TestStatusEnum(Enum):
    PASS = 'PASS'
    FAIL = 'FAIL'
    ABORTED = 'ABORTED'


class JiraXrayHandler:

    def __init__(self):
        self.base_url = JiraConfiguration.endpoint
        self.execution_key = None
        self._mark = None
        self.auth = (JiraConfiguration.user_name, JiraConfiguration.password)
        self.headers = {
            'Content-Type': 'application/json'
        }
        self._management_version = None
        self._core_version = None

        self._collector_os_architecture = None
        self._collector_os_version = None
        self._collector_os_name = None
        self._collector_version = None

    @property
    def mark(self):
        return self._mark

    @mark.setter
    def mark(self, mark: str):
        self._mark = mark

    @property
    def collector_os_architecture(self):
        return self._collector_os_architecture

    @collector_os_architecture.setter
    def collector_os_architecture(self, collector_os_architecture: str):
        self._collector_os_architecture = collector_os_architecture.replace(' ', '-')

    @property
    def collector_os_version(self):
        return self._collector_os_version

    @collector_os_version.setter
    def collector_os_version(self, collector_os_version: str):
        self._collector_os_version = collector_os_version.replace(' ', '-')

    @property
    def collector_os_name(self):
        return self._collector_os_name

    @collector_os_name.setter
    def collector_os_name(self, collector_os_name: str):
        self._collector_os_name = collector_os_name.replace(' ', '-')

    @property
    def collector_version(self):
        return self._collector_version

    @collector_version.setter
    def collector_version(self, collector_version: str):
        self._collector_version = collector_version

    @property
    def management_version(self):
        return self._management_version

    @management_version.setter
    def management_version(self, management_version: Management):
        self._management_version = management_version

    @property
    def core_version(self):
        return self._core_version

    @core_version.setter
    def core_version(self, core_version: Management):
        self._core_version = core_version

    def publish_test_result(self, test_key, status: TestStatusEnum):
        test = dict(testKey=test_key, status=status.value)
        execution_key = self.get_execution_key()
        data = dict(testExecutionKey=execution_key, tests=[test])
        data_as_json = json.dumps(data)
        endpoint = f'{self.base_url}/rest/raven/2.0/import/execution'
        try:
            response = requests.post(url=endpoint, headers=self.headers, data=data_as_json, auth=self.auth, verify=False)
            if not 200 <= response.status_code < 300:
                content = None
                try:
                    content = json.loads(response.content)
                finally:
                    assert False, f"Failed to publish test reults to Jira, test_key: {test}, statuse code: {response.status_code}, response content: {content}"
        except requests.exceptions.ConnectionError as e:
            Reporter.report('Fail to publish test result to Jira')
            raise e

    def get_execution_key(self):
        if self.execution_key is None:
            self.execution_key = self.create_test_execution()

        return self.execution_key

    @allure.step("Create test execution in Jira")
    def create_test_execution(self):

        test_environment = f'{self.collector_os_name}_{self.collector_os_architecture}'
        summary = f'Automation results for suite={self.mark} and collector={test_environment}'

        fields = {
            'fields': {
                'project': {'key': JiraConfiguration.project},
                'issuetype': {'name': "Test Execution"},
                'summary': summary,
                'labels': ['automation_regression_ng', self._mark],
                'description': f'automatically generated by the automation, report: {third_party_details.JENKINS_JOB}',
                # 'fixVersions':  [{"add" : {"name" : "release_TEST"}}],
                'assignee': {'name': JiraConfiguration.user_name},
                'customfield_11324': [test_environment], # Test environments
                'customfield_11326': ['EN-73386'], # Test Plan (master test plan for automation purposes)
                # 'customfield_12500': 'place_holder', # collector name
                'customfield_12413': self.collector_version, # collector version
                'customfield_12414': self.core_version, # core version
                'customfield_12415': self.management_version, # management version
                'customfield_12502': [self.collector_os_architecture,
                                      self.collector_os_version,
                                      self.collector_os_name], # collector type
            }
        }
        data_as_json = json.dumps(fields)
        endpoint = f'{self.base_url}/rest/api/latest/issue'
        response = requests.post(url=endpoint, headers=self.headers, data=data_as_json, auth=self.auth, verify=False)
        if not 200 <= response.status_code < 300:
            content = None
            try:
                content = json.loads(response.content)
            finally:
                assert False, f"Failed to create test execution in Jira, statuse code: {response.status_code}, response content: {content}"

        return json.loads(response.content).get('key')
